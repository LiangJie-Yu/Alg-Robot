## Abstruct
python：脚本语言。
除了基础语法外，对numpy，机器学习等库也需要着重学习。
## 标识符
第一个字符必须是字母表中字母或下划线''。
标识符的其他的部分有字母、数字和下划线组成。
标识符对大小写敏感

## 注释
单行：#开头
多行：（'''）三个单引号或者（"""）三个双引号
```python
#单行注释
"""
多行注释
"""
```
## 基本函数
### input输入&等待用户输入
接受输入，传入一个==字符串==
```python
a= int(input())
```

### print基本输出函数
将变量输出（或者说，打印）到控制台，**默认输出==换行**==，如果要实现不换行需要在变量末尾加上 ==end=""==

### import与from...import导入相应模块
- 将整个模块 (somemodule) 导入，格式为：​ `import somemodule`
- 从某个模块中导入某个函数,格式为：​ `from somemodule import somefunction`
- 从某个模块中导入多个函数,格式为：​ `from somemodule import firstfunc, secondfunc, thirdfunc`
- 将某个模块中的全部函数导入，格式为：​ `from somemodule import *`
```python
from sys import argv,path #导入特定的成员
```
导入模块，扩展的“插件库”模块，来源：Python标准库（安装Python时自带的但没预装在内存中），第三方库（别人写好分享的），自定义模块；而上面的input、print、len、type、max等则是自带的

## 基本数据类型
在python中，变量就是变量，它没有类型，我们所说的"类型"是变量所指的==内存中对象的类型==

| 类型名称 |                                 | 核心特点          | 是否可变 | 有序性    |
| ---- | ------------------------------- | ------------- | ---- | ------ |
| 数字   | Numbers(int,float.bool.complex) | 存储数值，不可变      | 不可变  | -      |
| 字符串  | String'   ' /"  "               | 文本，字符，不可变，可索引 | 不可变  | 有序     |
| 元组   | Tuple(  )                       | 内容不可修改，安全稳定   | 不可变  | 有序     |
| 列表   | List[  ]                        | 最常用，可增删改查     | 可变   | 有序     |
| 集合   | Set{  }                         | 自动去重，无索引，无重复  | 可变   | 无序     |
| 字典   | Dict{key:value}(key键value值)     | 键值对，键唯一，查找快   | 可变   | 3.7+有序 |
### 可变数据与不可变数据
可变数据和不可变数据的“变”是相对于==引用地址==来说的，不是不能改变其数据，而是改变数据的时候会不会改变变量的引用地址。
即可变数据对象本身的内存地址id不变，但内部的值可以被修改；不可变数据对象本身的值不能被修改，如要改变，只能让变量指向新的地址。
```python
x=1
print(id(x))  #输出地址为140724982006696
x=2
print(id(x))  #输出地址为140724982006728
```
### Numbers数字
#### 定义

- Python 3 支持 int（整型）、float（浮点型）、bool（布尔型）、complex（复数）
- 当你指定一个值时，Number 对象就会被创建：var1 = 1
- 可以使用 del 语句删除一些对象引用 del var
- 数值运算
```python
5 + 4 # 加法 9
4.3 - 2 # 减法 2.3
3 * 7 # 乘法 21
2 / 4 # 除法，得到一个浮点数 0.5 
2 // 4 # 除法，得到一个整数 0 
17 % 3 # 取余 2
2 ** 5 # 乘方 32
a,b=b,a+b先计算右边的再同时赋值左边
```
#### 注意
1. Python 可以同时为多个变量赋值，如 a, b = 1, 2
2. 一个变量可以通过赋值指向不同类型的对象
3. 数值的除法（/）总是返回一个浮点数，要获取整数使用​`//`​操作符
4. 在混合计算时，Python 会把整型转换成为浮点数
### String字符串
#### 定义

1. Python 中单引号和双引号使用完全相同，但单引号和双引号不能匹配
2. 使用三对引号('''或""")可以囊括一个多行字符串
3. 与其他语言相似，python也使用 '\'作为转义字符
4. 自然字符串， 通过在字符串前加 r 或 R。 如 r"this is a line with \n" 则\n会显示，并不是换行
5. Python 允许处理 unicode 字符串，加前缀 u 或 U
6. 索引从左往右0开始，从右往左以 -1 开始
7. Python中的字符串不能改变
8. Python 没有单独的字符类型，一个字符就是长度为 1 的字符串
9. 字符串的截取的语法格式如下：变量 **[头下标: 尾下标: 步长]**
10. 与 C 字符串不同的是，Python 字符串不能被改变。**向一个索引位置赋值，比如 word[0] = m' 会导致错误**
#### 实例
```python
str='W3Cschool' print(str)  #输出字符串 
print(str[0:-1])   #输出第一个到倒数第二个的所有字符 
print(str[0])  #输出字符串第一个字符 
print(str[2:5])  #输出从第三个开始到第五个的字符 
print(str[2:])  #输出从第三个开始后的所有字符 
print(str[1:5:2])  #输出从第二个开始到第五个且每隔两个的字符 
print(str * 2)  #输出字符串两次 
print(str + '你好') #连接字符串 
print('hello\nW3Cschool') #使用反斜杠+n转义特殊字符（相当于换行）
print(r'hello\nW3Cschool') #在字符串前面添加一个 r，表示原始字符串，不会发生转义
```
#### 注意
1. 反斜杠可以用来转义，使用 r 可以让反斜杠不发生转义
2. 字符串可以用 + 运算符连接在一起，用 * 运算符重复
3. Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始
4. Python 中的字符串不能改变

### Tuple元组
#### 定义
1. 元组与列表类似，不同之处在于元组的==元素不能修改==。元组写在小括号里，元素之间用逗号隔开。
2. 元组中的==元素类型可以不相同==：例：
3. 元组与字符串类似，可以被索引且下标索引从 0 开始，也可以进行截取/切片（看上面，这里不再赘述）。
4. 其实，可以把字符串看作一种特殊的元组。
5. 修改元组元素的操作是非法的
6. 虽然 tuple 的元素不可改变，但它可以包含可变的对象，比如 list 列表。
7. 构造包含 0 个或 1 个元素的 tuple 是个特殊的问题，所以有一些额外的语法规则，见下面的示例
8. 元组支持用 + 操作符 
#### 实例
```python
a = (1991, 2014, 'physics', 'math')#元素可不相同

tup1 = ()#空元组 
tup2 = (20,)#一个元素，需要在元素后添加逗号

tup1, tup2 = (1, 2, 3), (4, 5, 6)
print(tup1+tup2) #输出(1, 2, 3, 4, 5, 6）
```
#### 注意
- 1、与字符串一样，元组的元素不能修改。
- 2、元组也可以被索引和切片，方法都是一样的。
- 3、注意构造包含 0 或 1 个元素的元组的特殊语法规则。
- 4、元组也可以使用 + 操作符进行拼接。

### List列表
#### 定义
1. 列表是写在方括号之间、用逗号分隔开的元素列表。列表中元素的类型可以不相同
2. 和字符串一样，列表同样可以被索引和切片，列表被切片后返回一个包含所需元素的新列表。详细的在这里就不赘述了。
3. 列表还支持串联操作，使用 + 操作符：
4. 与字符串不一样的是，列表中的**元素是可以改变**		
5. List 内置了有很多方法，例如 append()、pop()，详见“python进阶-数据结构”
#### 实例
```python
a = ['him', 25, 100, 'her']#元素类型可以不相同

a = [1, 2, 3, 4, 5]
a + [6, 7, 8] #输出：[1, 2, 3, 4, 5, 6, 7, 8]

a = [1, 2, 3, 4, 5, 6] 
a[0] = 9#输出[9, 2, 3, 4, 5, 6]
```
#### 注意
1. List 写在方括号之间，元素用逗号隔开。
2. 和字符串一样，List 可以被索引和切片。
3. List 可以使用 + 操作符进行拼接。
4. List 中的元素是可以改变的。
### Sets集合
#### 定义
1. 集合（set）是一个==无序不重复==元素的集。
2. 基本功能是进行**成员关系测试**和==**消除重复元素**==。
3. 可以使用大括号 或者 set() 函数创建 set 集合
#### 实例
```python
student = {'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'} 
print(student) #重复的元素被自动去掉 {'Jim', 'Jack', 'Mary', 'Tom', 'Rose'} 
'Rose' in student #进行成员测试 （membership testing）
True 

# set可以进行集合运算
a = set('abracadabra')
b = set('alacazam') 
a {'a', 'b', 'c', 'd', 'r'} 
a - b # a和b的差集 {'b', 'd', 'r'} 
a | b # a和b的并集 {'l', 'm', 'a', 'b', 'c', 'd', 'z', 'r'} 
a & b # a和b的交集 {'a', 'c'} 
a ^ b # a和b中不同时存在的元素 {'l', 'm', 'b', 'd', 'z', 'r'}
```
#### 注意
1. 创建一个空集合必须用 set() 而不是 { }，因为{ }是用来创建一个空字典。
### Dictionaries字典
#### 格式：==Dict { key : value }==
#### 定义
1. 字典（dictionary）是 Python 中另一个非常有用的内置数据类型。
2. 字典是一种映射类型（mapping type），它是一个无序的键值对（key-value）集合。
3. 关键字（key）必须使用不可变类型，也就是说list和包含可变类型的 tuple 不能做关键字。
4. 在同一个字典中，**关键字（key）必须互不相同**。
5. 构造函数 dict() 直接从键值对 sequence 中构建字典，当然也可以进行推导
6. 另外，字典类型也有一些内置的函数，例如 clear()、keys()、values() 等。
#### 实例
```python
dic = {} # 创建空字典 
tel = {'Jack':1557, 'Tom':1320, 'Rose':1886}
tel {'Tom': 1320, 'Jack': 1557, 'Rose': 1886} 
tel['Jack'] #主要的操作：通过key查询 1557
del tel['Rose'] #删除一个键值对 
tel['Mary'] = 4127 #添加一个键值对 
tel {'Tom': 1320, 'Jack': 1557, 'Mary': 4127}
list(tel.keys()) #返回所有key组成的list['Tom', 'Jack', 'Mary'] 
sorted(tel.keys()) #按key排序['Jack', 'Mary', 'Tom'] 
'Tom' in tel # 成员测试 True 
'Mary' not in tel # 成员测试 False

dict([('sape', 4139), ('guido', 4127), ('jack', 4098)]) 
{'jack': 4098, 'sape': 4139, 'guido': 4127} 
{x: x2 for x in (2, 4, 6)} {2: 4, 4: 16, 6: 36} 
dict(sape=4139, guido=4127, jack=4098)
{'jack': 4098, 'sape': 4139, 'guido': 4127}

```
#### 注意
1、字典是一种映射类型，它的元素是键值对。
2、字典的关键字必须为不可变类型，且不能重复。
3、创建空字典使用 { }。
### 数据类型转换
```python
int('123')
#输出：123
int(12.34)
#输出：12
float('12.34')
#输出：12.34
str(1.23)
#输出：'1.23'
str(100)
#输出：'100'
bool(1)
#输出：True
bool('')
#输出：False
```

### 类型查询判断
#### type(x)->查询类型
直接返回变量的精确类型，不考虑继承关系（不认为子类是一种父类类型）
```python
x=1
print(type(x))  #输出int
x=1.2
print(type(x))  #输出float
x="1"
print(type(x))  #输出str 
```
#### isinstance(x，要判断的类型)->判断类型
isinstance(x，要判断的类型)
会考虑继承关系，更适合做类型判断，在开发中更常用
```python
a=111
print(isinstance(a,int))  #判断单一类型 #输出True表示判断正确
print(isinstance(a,(int,float))) #同时判断多种类型 #类型需要用元组包起来 #只要是整数或者浮点数都返回Ture
```

## 删除函数
| 函数       | 作用                      | 用法                                                     | 是否返回值  | 适用对象     | 如何使用      | 核心结果            |
| -------- | ----------------------- | ------------------------------------------------------ | ------ | -------- | --------- | --------------- |
| del      | 按**索引/键**删除，可删整个变量      | del lst[0]<br><br>del d["name"]<br><br>del lst<br><br> | 不      | 列表，字典，变量 | 想按位置删     | **删元素 / 删整个变量** |
| remove() | 按**值**删除（第一个匹配值）        | lst.remove(5)                                          | 不      | 列表       | 想按值删      | **删掉对应的值**      |
| pop()    | 按**索引/键**删除，并**返回被删的值** | lst.pop(0)<br><br>d.pop("name")                        | 返回被删元素 | 列表，字典    | 想删了还要用这个值 | **删元素并拿回值**     |
| clear()  | **清空所有内容**，变量还在         | lst.clear()<br><br>d.clear()                           | 不      | 列表，字典，集合 | 想清空内容     | **内容变空，变量还在**   |


## 运算符
### 算术运算符
以下假设变量 a 为 21，变量 b 为 10：

| 运算符 | 描述                        | 实例                        |
| --- | ------------------------- | ------------------------- |
| +   | 加 - 两个对象相加                | a + b 输出结果 31             |
| -   | 减 - 得到负数或是一个数减去另一个数       | a - b = 11                |
| *   | 乘 - 两个数相乘或是返回一个被重复若干次的字符串 | a * b =210                |
| /   | 除 - x 除以 y                | a / b = 2.1               |
| %   | 取模 - 返回除法的余数              | a % b = 1                 |
| **  | 幂 - 返回 x 的 y 次幂           | a ** b 为 21 的 10 次方       |
| //  | 取整除 - 返回商的整数部分            | 9//2 = 4 , 9.0//2.0 = 4.0 |
### 比较（关系）运算符
以下假设变量 a 为 10，变量 b 为 20

| 运算符 | 描述                    | 实例                |
| --- | --------------------- | ----------------- |
| ==  | 等于 -- 比较对象是否相等        | (a == b) 返回 False |
| ！=  | 不等于 -- 比较两个对象是否不相等    | (a != b) 返回 True. |
| >   | 大于 -- 返回 x 是否大于 y     | (a > b) 返回 False  |
| <   | 小于 -- 返回 x 是否小于 y     | (a < b) 返回 True   |
| >=  | 大于等于 -- 返回 x 是否大于等于 y | (a >= b) 返回 False |
| <=  | 小于等于 -- 返回 x 是否小于等于 y | (a <= b) 返回 True  |
所有比较运算符返回 1 表示真，返回 0 表示假。这分别与特殊的变量 True 和 False 等价。注意：True和False的首字母为大写
### 赋值运算符
| 运算符 | 描述       | 实例                           |
| --- | -------- | ---------------------------- |
| =   | 简单的赋值运算符 | c = a + b 将 a + b 的运算结果赋值为 c |
| +=  | 加法赋值运算符  | c += a 等效于 c = c + a         |
| -=  | 减法赋值运算符  | c -= a 等效于 c = c - a         |
| *=  | 乘法赋值运算符  | c *= a 等效于 c = c * a         |
| /=  | 除法赋值运算符  | c /= a 等效于 c = c / a         |
| %=  | 取模赋值运算符  | c %= a 等效于 c = c % a         |
| **= | 幂赋值运算符   | c **= a 等效于 c = c^ a         |
| //= | 取整除赋值运算符 | c //= a 等效于 c = c // a       |
### 逻辑运算符
Python 语言支持逻辑运算符，以下假设变量 a 为 10, b 为 20

| 运算符 | 逻辑表达式   | 描述                                                   | 实例                    |     |
| --- | ------- | ---------------------------------------------------- | --------------------- | --- |
| and | x and y | 布尔"与" - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。  | (a and b) 返回 20       | 串联  |
| or  | x or y  | 布尔"或" - 如果 x 是 True，它返回 x的值，否则它返回 y 的计算值。            | (a or b) 返回 10        | 并联  |
| not | not x   | 布尔"非" - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。 | not(a and b) 返回 False | 取反  |
### 位运算符
按位运算符是把数字看作二进制来进行计算的。Python 中的按位运算法则如下：
下表中变量 a 为 60，b 为 13。

|             | 按位与运算（a&b） | 按位或运算（a\|b） | 按位异或（a^b） |
| ----------- | ---------- | ----------- | --------- |
| a(60)的二进制表示 | 0011 1100  | 0011 1100   | 0011 1100 |
| b(13)的二进制表示 | 0000 1101  | 0000 1101   | 0000 1101 |
| 运算结果        | 0000 1100  | 0011 1101   | 0011 0001 |
| 结果的十进制表示    | 12         | 61          | 49        |

|             | 按位取反（~a）  | 左移（a<<2）  | 右移(a>>2)  |
| ----------- | --------- | --------- | --------- |
| a(60)的二进制表示 | 0011 1100 | 0011 1100 | 0011 1100 |
| 运算结果        | 1100 0011 | 1111 0000 | 0000 1111 |
| 结果的十进制表示    | -61       | 240       | 15        |
### 原码，补码和反码
原码：假设机器字长为n，原码就是用一个n位的二进制数，其中最高位为符号位：正数是0，负数是1。剩下的表示概数的绝对值，位数如果不够就用0补全。  
反码：在原码的基础上，**符号位不变**其他位取反，也就是就是0变1，1变0。  
补码：在反码的基础上加1。    
PS：正数的原、反、补码都一样，0的原码跟反码都有两个，因为这里0被分为+0和-0。  
按位取反和反码有一定的相似之处但又不尽相同（反码符号位不取反）。  
在计算机中，是以*补码*的形式存放数据的。1100 0011刚好对应-61。  
-61的原码-> 1011 1101->反码->1100 0010->补码->1100 0011

| 运算符 | 描述                                                      | 实例                                 |
| --- | ------------------------------------------------------- | ---------------------------------- |
| &   | 按位**与**运算符：参与运算的两个值,如果两个相应位都为  1,则该位的结果为 1,否则为 0        | (a & b) 输出结果 12 ，二进制解释： 0000 1100  |
| \|  | 按位**或**运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1                   | (a \| b) 输出结果 61 ，二进制解释： 0011 1101 |
| ^   | 按位**异或**运算符：当两对应的二进位相异（不同）时，结果为 1                       | (a ^ b) 输出结果 49 ，二进制解释： 0011 0001  |
| ~   | 按位**取反**运算符：对数据的每个二进制位取反,即把 1 变为 0，把 0 变为 1             | (~a ) 输出结果 -61 ，二进制解释： 1100 0011   |
| <<  | **左移动**运算符：运算数的各二进位全部左移若干位，由"<<"右边的数指定移动的位数，高位丢弃，低位补 0。 | a << 2 输出结果 240 ，二进制解释： 1111 0000  |
| >>  | **右移动**运算符：把">>"左边的运算数的各二进位全部右移若干位，">>"右边的数指定移动的位数      | a >> 2 输出结果 15 ，二进制解释： 0000 1111   |

### 成员运算符
| 运算符    | 描述                               | 实例                                 |
| ------ | -------------------------------- | ---------------------------------- |
| in     | 如果在指定的序列中找到值返回 True，否则返回 False   | x 在 y 序列中 , 如果 x 在 y 序列中返回 True。   |
| not in | 如果在指定的序列中没有找到值返回 True，否则返回 False | x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。 |
### 身份运算符
| 运算符    | 描述                        | 实例                                                   |
| ------ | ------------------------- | ---------------------------------------------------- |
| is     | is 是判断两个标识符是不是引用自一个对象     | x is y, 如果 id(x) 等于 id(y) , **is** 返回结果 True         |
| is not | is not 是判断两个标识符是不是引用自不同对象 | x is not y, 如果 id(x) 不等于 id(y). **is not** 返回结果 True |
#### 各种类型的情况
| 数据类型            | 实例            | a is b | 原因                       |
| --------------- | ------------- | ------ | ------------------------ |
| 小整数（-5~256）     | a=20;b=20     | Ture   | 小整数缓存范围是-5~256，复用同一个内存对象 |
| 小整数（-5~256）     | a=20;b=50     | False  | 不复用同一个对象，id不同            |
| 普通整数（除小整数的其他整数） |               | False  | 超出小整数缓存范围不会复用对象，不缓存，新建对象 |
| 浮点数             | a=Ture;b=Ture | Ture   | 全局单例                     |
| 布尔值             | a=None;b=None | Ture   | 全局单例                     |
| 短字符串            |               | Ture   | 字符串驻留优化                  |
| 长/复杂字符串         |               | False  | 不驻留（长字符串的判断取决于解释器）       |
| list列表          |               | False  | 每次[]都是新对象                |
| tuple元组         |               | False  | 不缓存                      |
| dict字典          |               | False  | 每次{}都是新对象                |
| set集合           |               | False  | 每次都是新对象                  |
#### 一定相同的情况（复用同一个内存对象/id相同）
| 情况           | 表达形式            |
| ------------ | --------------- |
| 互相赋值         | b=a             |
| 小整数缓存范围内且值相同 | -5~256          |
| 单例           | None,Ture,False |
#### 真实用途
| 场景        | 正确写法            | 为什么用is              |
| --------- | --------------- | ------------------- |
| 判断是否为空    | if x is None    | 最标准，最快，最安全          |
| 判断真假单例    | if flag is Ture | 避免0/1干扰             |
| 判断是否同一个对象 | if a is b       | 看是否指向同一个内存地址，id是否相同 |
##### 注意：
== 比内容
is    比身份（内存对象）（id）
除了小整数（-5~256）,None,Ture,False其他所有类型，值相同!=对象相同







## 条件判断
### if-elif-else
```python
if 条件为True: 
	statement_block_1 
elif 条件为True: 
	statement_block_2 
else: 
	statement_block_3
```

### match-case(在python3.10之后版本用)
```python
def http_error(status): 
	match status: 
		case 400: 
			return "Bad request" 
		case 404: 
			return "Not found" 
		case 418: 
			return "I'm a teapot" 
		case _ : 
			return "Something's wrong with the Internet"
```



## 循环
### while
```python
while <条件为True>:
	statements
```
### for
```python
for <循环变量> in <可迭代对象>: 
	<statements> 
else:  # 只有循环正常结束完后才执行，中途break跳出循环就不执行
	<statements>
```
### range()遍历数字时常用

```python
for <循环变量> in range(<start>, <stop>, <step>):
	<statements>
```
#### 特别注意
1. 循环变量从start开始，不包含stop
2. 在省略的情况下默认start=0, step=1
3. 不能只省略 start，必须按照 start→stop→step 的顺序传参
4. 无论哪种写法，stop 都是必填项，且循环值永远不包含stop
####  range(len())遍历一个序列的索引
```python
a = ['Mary', 'had', 'a', 'little', 'lamb'] 
for i in range(len(a)):
	print(i, a[i])
```
### break与continue及循环中的 else 子句
break直接跳出循环
continue跳出当前循环
循环中的else子句，只有循环正常结束完后才执行，中途break跳出循环就不执行
### pass语句
语法上必须有代码块但程序无需执行任何逻辑时使用，仅作为占位符补全语法框架
```python
def a(val):#通过占位，告诉后来的开发者这里我们之后再写
	pass
i = 10
while i:
	pass
a=2
```
## 迭代器与生成器
### 迭代器iter()与next

| 特性   | 普通迭代器（`iter(list)`） | 生成器迭代器（`yield` 函数） |
| ---- | ------------------- | ------------------ |
| 元素来源 | 提前存在的（列表 / 字符串）     | 实时计算生成（无提前存储）      |
| 内存占用 | 等于原数据大小（因为元素已存在）    | 极低（只存计算状态，不存元素）    |
| 核心逻辑 | 单纯 “遍历返回”           | 自定义 “计算 + 返回”      |
| 创建方式 | iter(可迭代对象)         | 生成器函数（def + yield） |

#### 迭代器
- 迭代器是访问集合元素的一种方法
- 是一个可以记住遍历的位置的对象
- 从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退
#### 基本方法：iter()与next
条件：字符串，列表或元组对象
iter()相当于“转换工具”，将列表/字符串/元组转换成只能按照顺序访问的迭代器
next()相当于“按照iter的顺序，拿一个少一个，不可逆”

```python
import sys # 引入 sys 模块 
list=[1,2,3,4] 
it = iter(list) # 创建迭代器对象 
while True: #无限循环
	try: 
		print (next(it)) # 尝试获取迭代器的下一个元素并打印
	except StopIteration: # 捕获"迭代器没有下一个元素"的异常
		sys.exit()# 捕获到异常后，退出程序
#`try...except` “尝试执行一段代码，如果这段代码出错了，就执行我们提前准备好的‘补救代码’，而不是让程序直接崩溃”**。
```
注意
1. 与普通列表的区别：迭代器是==一次性、顺序访问==，普通列表中的元素不会因为用过消失，可随便拿任意位置的元素
2. 取完最后一个后，再调用next()就会触发`StopIteration` 异常
### 生成器迭代器:yield
在调用生成器运行的过程中，每次遇到 yield 时函数会暂停并保存当前所有的运行信息，返回 yield 的值。并在下一次执行 next() 方法时从当前位置继续运行
#### 实例：（利用yield实现斐波那契数列）
```python
import sys

def fibonacci(n):
	a, b, counter = 0, 1, 0
	while True:
		if (counter > n): 
			return
		yield a
		a, b = b, a + b
		counter += 1
f = fibonacci(10) #f是一个迭代器，由生成器返回生成
while True:
	try:
		print (next(f), end=" ")
	except StopIteration:
		sys.exit()
#输出结果
#0 1 1 2 3 5 8 13 21 34 55
```
## 函数
### def定义函数
格式：
```python
def 函数名（参数列表）： 
	函数体
```
实例：
```python
def area(width, height): 
	return width * height
print(" area =", area(4, 5))
#输出结果： area =20
```
### 函数变量作用域
局部作用域：定义在函数内部的变量拥有局部作用域，只能在函数内部用
全局作用域：定义在函数外的拥有全局作用域，全局可用
```python
a=10#全局作用域
def c(a):
	a=13#局部作用域
	return a
print(c(a))
#输出结果：13
```

## 切片
从==**列表list，字符串str，元组tuple**==里，截取出一段
左包含，右不包含
```python
<变量>【<start>:<stop>:<step>】
```
*跟上文的循环中的range()相似*
### 注意：
1. start默认从第0开始，stop默认到最后一个元素，step默认是1
2. 下标越界不报错，如果是列表则返回空列表[ ]，自动截取到合理范围
3. 切片不影响原序列，会返回到一个新的序列
4. 列表返回新列表，元组返回新元组，类型不变
5. 对于二位列表（矩阵），可以使用嵌套切片
### 示例
```python
a=[10,20,30,40,50]
a[1:3] #从下标1取到下标3（不包含3）
#输出结果：[20,30]
a[:3] #从头取到下标3（不包含3）
#输出结果：[10,20,30]
a[2:] #从下标2取到最后一个
#输出结果：[30，40，50]
a[-2:] #倒着区最后两个
#输出结果：[40，50]
a[:：2] #每隔一个取一个
#输出结果：[10，30，50]
a[：：-1] #从头取到下标3（不包含3）
#输出结果：[50，40，30，20，10]

二位列表如：a[1:3][2:4]

```


## 